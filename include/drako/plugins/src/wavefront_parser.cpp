#include "drako/plugins/wavefront_parser.hpp"

#include <charconv>
#include <istream>
#include <string>
#include <string_view>
#include <tuple>
#include <vector>

namespace drako::plugins::wavefront
{
    const auto             DEFAULT_VERTEX_WEIGHT   = 1.f;
    const auto             DEFAULT_VERTEX_TEXCOORD = 0.f;
    const std::string_view OBJ_LINE_CONTINUATION   = "\x5c";

    using _ec = obj_error_code;
    using _v_container  = std::vector<float>;
    using _vn_container = std::vector<float>;
    using _vt_container = std::vector<float>;

    struct _parser_token
    {
        char*  begin;
        char*  end;
        size_t size;
        size_t row;
        size_t col;

        explicit operator std::string_view()
        {
            return std::string_view{ begin, size };
        }
    };

    struct _parser_local_state
    {
        _v_container  points;
        _vn_container normals;
        _vt_container texcoords;
    };

    struct _parser_global_state
    {
        std::vector<obj_parser_warning>& warnings;
        std::vector<obj_parser_error>&   errors;
    };

    DRAKO_NODISCARD DRAKO_FORCE_INLINE obj_parser_error
    _make_line_error(obj_error_code errc) noexcept
    {
        obj_parser_error error{};
        error._char_index = 0;
        error._row_number = 0;
        error._col_number = 0;
        error._errc       = errc;
        return error;
    }

    DRAKO_NODISCARD DRAKO_FORCE_INLINE obj_parser_error
    _make_token_error(const _parser_token& tk, obj_error_code errc) noexcept
    {
        obj_parser_error error{};
        error._char_index = tk.begin;
        error._row_number = tk.row;
        error._col_number = tk.col;
        error._errc       = errc;
        return error;
    }



    DRAKO_NODISCARD std::tuple<obj_object, std::vector<obj_parser_warning>, std::vector<obj_parser_error>>
    parse(const std::string_view source, const obj_parser_config& config)
    {
        if (std::empty(source))
            return { {}, {}, {} };

        obj_object                      result;
        std::vector<obj_parser_warning> warnings{}; // logs warnings generated by parsing
        std::vector<obj_parser_error>   errors{};   // logs error generated by parsing

        _v_container          v_points(config.expected_vertex_count * 3);    // vertex geometry
        _vn_container         v_normals(config.expected_vertex_count * 3);   // vertex normals
        _vt_container         v_texcoords(config.expected_vertex_count * 3); // vertex texcoords
        std::vector<uint32_t> faces(config.expected_triangle_count * 3);

        std::size_t curr_line_index = 1;
        for (const auto line_begin = std::cbegin(source); line_begin != std::cend(source); ++curr_line_index)
        {
            const auto line_end = std::find(line_begin, std::cend(source), '\n');

            const std::string_view curr_line{ line_begin, line_end };
            if (std::empty(curr_line))
                continue; // skip empty line

            const std::string_view tag{ curr_line.data(), curr_line.find_first_not_of(' ', 0) };

            // comment line statement
            // SYNTAX:
            //      # [...]
            if (tag == "#")
                continue; // skip comment line

            std::vector<_parser_token> args{ 100 };

            do
            {
                for (auto [last_token, line_end] = std::tuple{ curr_line.data(), curr_line.data() + curr_line.size() };
                     last_token != line_end;)
                {
                    // skip leading whitespace
                    const auto token_begin = std::find_if(last_token, line_end,
                        [](auto c) { return !std::isspace(static_cast<unsigned char>(c)); });

                    // reach trailing whitespace or line termination
                    const auto token_end = std::find_if(token_begin, line_end,
                        [](auto c) { return std::isspace(static_cast<unsigned char>(c)); });

                    const auto token_lenght = std::distance(token_begin, token_end);
                    args.emplace_back(token_begin, token_lenght);

                    last_token = token_end;
                }
            } while (static_cast<std::string_view>(args.back()) == OBJ_LINE_CONTINUATION);

            // geometric vertex statement
            // SYNTAX:
            //      v x y z [w]
            // DEFAULT:
            //      w = 1.0
            if (tag == "v")
            {
                _v_parse(args, errors);
                continue;
            }

            if (tag == "vn") // vertex normal data: vn x y z
            {
                _vn_parse(args, errors);
                continue;
            }

            if (tag == "vt") // vertex uv data: vt u [v] [w]
            {
                _vt_parse(args, errors);
                continue;
            }

            if (tag == "f") // face element: v1/[vt1]/[vn1] v2/[vt2]/[vn2] v3/[vt3]/[vn3] [v4/vt4/vn4 ...]
            {
                _f_parse(args, errors);
                continue;
            }

            // grouping statement
            // SYNTAX:
            //      g group_name1 [group_name2 ...]
            // DEFAULT:
            //      group_name = default
            if (tag == "g")
                continue; // ignored in the current implementation

            // smoothing group statement
            // SYNTAX:
            //      s group_number
            if (tag == "s")
                continue; // ignored in the current implementation

            // material reference statement
            // SYNTAX:
            //      usemtl material_name
            if (tag == "usemtl")
                continue; // ignored in the current implementation

            // object name statement; optional
            // SYNTAX:
            //      o object_name
            if (tag == "o")
            {
                if (const auto argc = std::size(args); argc == 1)
                {
                    result.name = std::string{ args[0].begin, args[0].end }; // TODO: create multiple objects if multiple names
                }
                else
                {
                    errors.emplace_back(_make_line_error(_ec::tag_o_invalid_args_count));
                }
                continue;
            }

            errors.emplace_back(_make_line_error(_ec::unknown_tag)); // unknown tag
        }
        
        return { result, warnings, errors };
    }


    static void _v_parse(
        const std::vector<_parser_token>& args,
        _parser_local_state               ctx,
        _parser_global_state              parser) noexcept
    {
        const auto V_MIN_ARGC = 3;
        const auto V_MAX_ARGC = 4;

        if (const auto argc = std::size(args); argc < V_MIN_ARGC || argc > V_MAX_ARGC)
        {
            obj_parser_error error{};
            error._errc = obj_error_code::tag_v_invalid_args_count;
            parser.errors.emplace_back(error);
        }
        else
        {
            for (auto i = 0; i < argc; ++i)
            {
                float coord;
                if (const auto [ptr, errc] = std::from_chars(args[i].begin, args[i].end, coord);
                    errc != std::errc{})
                {
                    parser.errors.emplace_back(_make_token_error(args[i], _ec::invalid_arg_format));
                }
                ctx.points.emplace_back(coord);
            }
            for (auto i = V_MAX_ARGC - argc; i < V_MAX_ARGC; ++i)
            {
                ctx.points.emplace_back(DEFAULT_VERTEX_WEIGHT);
            }
        }
    }

    static void _vn_parse(
        const std::vector<_parser_token>& args,
        _parser_local_state               ctx,
        _parser_global_state              parser) noexcept
    {
        const auto VN_ARGC = 3;
        // NOTE: normal vector is not required to be normalized by .OBJ specs
        if (const auto argc = std::size(args); argc != VN_ARGC)
        {
            const auto error = _make_line_error(_ec::tag_vn_invalid_args_count);
            parser.errors.emplace_back(error);
        }
        else
        {
            for (auto i = 0; i < argc; ++i)
            {
                float normal = 0;
                if (const auto [ptr, err] = std::from_chars(args[i].begin, args[i].end, normal);
                    err != std::errc{})
                {
                    const auto error = _make_token_error(args[i], _ec::invalid_arg_format);
                    parser.errors.emplace_back(error);
                }
                ctx.normals.emplace_back(normal);
            }
        }
    }

    static void _vt_parse(
        const std::vector<_parser_token>& args,
        _parser_local_state               ctx,
        _parser_global_state              parser) noexcept
    {
        const auto VT_MIN_ARGC = 1;
        const auto VT_MAX_ARGC = 3;

        if (const auto argc = std::size(args); argc < VT_MIN_ARGC || argc > VT_MAX_ARGC)
        {
            const auto error = _make_line_error(_ec::tag_vt_invalid_args_count);
            parser.errors.emplace_back(error);
        }
        else
        {
            for (auto i = 0; i < argc; ++i)
            {
                float texcoord = DEFAULT_VERTEX_TEXCOORD;
                if (const auto [ptr, err] = std::from_chars(args[i].begin, args[i].end, texcoord);
                    err != std::errc{})
                {
                    const auto error = _make_token_error(args[i], _ec::invalid_arg_format);
                    parser.errors.emplace_back(error);
                }
                ctx.texcoords.emplace_back(texcoord);
            }
            for (auto i = argc; i < VT_MAX_ARGC; ++i)
            {
                ctx.texcoords.emplace_back(DEFAULT_VERTEX_TEXCOORD);
            }
        }
    }

    static void _f_parse(
        const std::vector<_parser_token>& args,
        _parser_local_state               ctx,
        _parser_global_state              parser) noexcept
    {
        if (size(args) < 4)
        {
            const auto error = _make_line_error(_ec::tag_f_invalid_args_count);
            parser.errors.emplace_back(error);
            return;
        }

        std::vector<int32_t> v(args.size());  // geometric vertices
        std::vector<int32_t> vt(args.size()); // texture vertices
        std::vector<int32_t> vn(args.size()); // vertex normals
        for (auto i = 1; i < args.size(); ++i)
        {
            // required by syntax of the form v/[vt]/[vn]
            if (std::count(args[i].begin, args[i].end, '/') != 2)
            {
                const auto error = _make_token_error(args[i], _ec::tag_f_invalid_args_format);
                parser.errors.emplace_back(error);
                break;
            }
            const auto v_begin = args[i].begin;
            const auto v_end   = std::find(args[i].begin, args[i].end, '/');
            //std::from_chars(v_begin, v_end, v[i]);

            const auto vt_begin = std::next(v_end);
            const auto vt_end   = std::find(vt_begin, args[i].end, '/');
            if (std::distance(vt_begin, vt_end) > 0)
            {
                // TODO: parse vt token
            }

            const auto vn_begin = std::next(vt_end);
            const auto vn_end   = args[i].end;
            if (std::distance(vt_begin, vt_end) > 0)
            {
                // TODO: parse vn token
            }
        }
    }

} // namespace drako::plugins::wavefront